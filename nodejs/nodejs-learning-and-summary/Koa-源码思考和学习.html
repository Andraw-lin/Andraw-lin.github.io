<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Koa 源码思考和学习</title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="好好学习，天天向上💪">
    <link rel="preload" href="/assets/css/0.styles.a748b10c.css" as="style"><link rel="preload" href="/assets/js/app.62b9dc26.js" as="script"><link rel="preload" href="/assets/js/2.1177bb59.js" as="script"><link rel="preload" href="/assets/js/80.dcf79b90.js" as="script"><link rel="prefetch" href="/assets/js/10.a3eb2dd7.js"><link rel="prefetch" href="/assets/js/100.a0587a90.js"><link rel="prefetch" href="/assets/js/101.bc61ee8e.js"><link rel="prefetch" href="/assets/js/102.6c9a3815.js"><link rel="prefetch" href="/assets/js/103.b27b845c.js"><link rel="prefetch" href="/assets/js/104.66db0c7a.js"><link rel="prefetch" href="/assets/js/105.900b60f5.js"><link rel="prefetch" href="/assets/js/106.9ccab627.js"><link rel="prefetch" href="/assets/js/107.29f88d5b.js"><link rel="prefetch" href="/assets/js/108.7981e08e.js"><link rel="prefetch" href="/assets/js/109.b33024ae.js"><link rel="prefetch" href="/assets/js/11.8bb20b07.js"><link rel="prefetch" href="/assets/js/110.3b0e64b4.js"><link rel="prefetch" href="/assets/js/111.8906ec31.js"><link rel="prefetch" href="/assets/js/112.f2c7dd3a.js"><link rel="prefetch" href="/assets/js/113.4126790c.js"><link rel="prefetch" href="/assets/js/114.f584a619.js"><link rel="prefetch" href="/assets/js/115.aa3ce001.js"><link rel="prefetch" href="/assets/js/116.9fc7b46a.js"><link rel="prefetch" href="/assets/js/117.02392f6b.js"><link rel="prefetch" href="/assets/js/118.be950d41.js"><link rel="prefetch" href="/assets/js/119.12f1724b.js"><link rel="prefetch" href="/assets/js/12.495dead6.js"><link rel="prefetch" href="/assets/js/120.8ec47d18.js"><link rel="prefetch" href="/assets/js/121.59dab4d9.js"><link rel="prefetch" href="/assets/js/122.ba73929a.js"><link rel="prefetch" href="/assets/js/123.f1f96cdb.js"><link rel="prefetch" href="/assets/js/124.e9ee3ab6.js"><link rel="prefetch" href="/assets/js/13.125ff0e3.js"><link rel="prefetch" href="/assets/js/14.638fd70a.js"><link rel="prefetch" href="/assets/js/15.c6414c00.js"><link rel="prefetch" href="/assets/js/16.e5534201.js"><link rel="prefetch" href="/assets/js/17.52920d84.js"><link rel="prefetch" href="/assets/js/18.e348c11a.js"><link rel="prefetch" href="/assets/js/19.3b4ed4a3.js"><link rel="prefetch" href="/assets/js/20.91aa8274.js"><link rel="prefetch" href="/assets/js/21.ef7544cb.js"><link rel="prefetch" href="/assets/js/22.c79ecf29.js"><link rel="prefetch" href="/assets/js/23.d74b8bc0.js"><link rel="prefetch" href="/assets/js/24.e1b7042f.js"><link rel="prefetch" href="/assets/js/25.ee0d54de.js"><link rel="prefetch" href="/assets/js/26.5ce41a17.js"><link rel="prefetch" href="/assets/js/27.506fca63.js"><link rel="prefetch" href="/assets/js/28.9e16b1bc.js"><link rel="prefetch" href="/assets/js/29.5f3fc6bd.js"><link rel="prefetch" href="/assets/js/3.56a9ad25.js"><link rel="prefetch" href="/assets/js/30.0b8b1b94.js"><link rel="prefetch" href="/assets/js/31.f972863c.js"><link rel="prefetch" href="/assets/js/32.58c91d73.js"><link rel="prefetch" href="/assets/js/33.40ec3e53.js"><link rel="prefetch" href="/assets/js/34.e948a627.js"><link rel="prefetch" href="/assets/js/35.89965b4f.js"><link rel="prefetch" href="/assets/js/36.773346af.js"><link rel="prefetch" href="/assets/js/37.8265a7ea.js"><link rel="prefetch" href="/assets/js/38.6814416d.js"><link rel="prefetch" href="/assets/js/39.2b4fe455.js"><link rel="prefetch" href="/assets/js/4.b41e69dd.js"><link rel="prefetch" href="/assets/js/40.fda79697.js"><link rel="prefetch" href="/assets/js/41.868f73f6.js"><link rel="prefetch" href="/assets/js/42.252a1ee9.js"><link rel="prefetch" href="/assets/js/43.4776516f.js"><link rel="prefetch" href="/assets/js/44.46eab99f.js"><link rel="prefetch" href="/assets/js/45.30564ad8.js"><link rel="prefetch" href="/assets/js/46.f0ad47dd.js"><link rel="prefetch" href="/assets/js/47.1b687bd7.js"><link rel="prefetch" href="/assets/js/48.16105aba.js"><link rel="prefetch" href="/assets/js/49.4c2c2c5e.js"><link rel="prefetch" href="/assets/js/5.5bc5eaa4.js"><link rel="prefetch" href="/assets/js/50.76421ba3.js"><link rel="prefetch" href="/assets/js/51.2f7f6f8b.js"><link rel="prefetch" href="/assets/js/52.4d4ee877.js"><link rel="prefetch" href="/assets/js/53.3c3a975c.js"><link rel="prefetch" href="/assets/js/54.4c9798c7.js"><link rel="prefetch" href="/assets/js/55.46fb092c.js"><link rel="prefetch" href="/assets/js/56.cc9a5bea.js"><link rel="prefetch" href="/assets/js/57.2dfac948.js"><link rel="prefetch" href="/assets/js/58.a1f91605.js"><link rel="prefetch" href="/assets/js/59.dbfdef0b.js"><link rel="prefetch" href="/assets/js/6.e416f727.js"><link rel="prefetch" href="/assets/js/60.a91a795c.js"><link rel="prefetch" href="/assets/js/61.bc1f5260.js"><link rel="prefetch" href="/assets/js/62.e2ccf952.js"><link rel="prefetch" href="/assets/js/63.2bd0c4cc.js"><link rel="prefetch" href="/assets/js/64.62c29a64.js"><link rel="prefetch" href="/assets/js/65.c110ae95.js"><link rel="prefetch" href="/assets/js/66.8e1a481f.js"><link rel="prefetch" href="/assets/js/67.30980d54.js"><link rel="prefetch" href="/assets/js/68.ba51dd58.js"><link rel="prefetch" href="/assets/js/69.336ac10e.js"><link rel="prefetch" href="/assets/js/7.671bf4d5.js"><link rel="prefetch" href="/assets/js/70.1a2832a2.js"><link rel="prefetch" href="/assets/js/71.5225ac1d.js"><link rel="prefetch" href="/assets/js/72.dd642248.js"><link rel="prefetch" href="/assets/js/73.84d46fc4.js"><link rel="prefetch" href="/assets/js/74.e1e7d470.js"><link rel="prefetch" href="/assets/js/75.2d7155c4.js"><link rel="prefetch" href="/assets/js/76.1b9e602d.js"><link rel="prefetch" href="/assets/js/77.cb915066.js"><link rel="prefetch" href="/assets/js/78.9bfd5a4d.js"><link rel="prefetch" href="/assets/js/79.cea94be8.js"><link rel="prefetch" href="/assets/js/8.c1053140.js"><link rel="prefetch" href="/assets/js/81.4bcdd175.js"><link rel="prefetch" href="/assets/js/82.a39c4dd4.js"><link rel="prefetch" href="/assets/js/83.d020fb52.js"><link rel="prefetch" href="/assets/js/84.b656b381.js"><link rel="prefetch" href="/assets/js/85.63f2aab3.js"><link rel="prefetch" href="/assets/js/86.f207c5aa.js"><link rel="prefetch" href="/assets/js/87.4ff13574.js"><link rel="prefetch" href="/assets/js/88.90318af9.js"><link rel="prefetch" href="/assets/js/89.c738a3bb.js"><link rel="prefetch" href="/assets/js/9.25317bd4.js"><link rel="prefetch" href="/assets/js/90.5cfedce5.js"><link rel="prefetch" href="/assets/js/91.65e09223.js"><link rel="prefetch" href="/assets/js/92.af40c683.js"><link rel="prefetch" href="/assets/js/93.3e34cd57.js"><link rel="prefetch" href="/assets/js/94.24583a56.js"><link rel="prefetch" href="/assets/js/95.f3157245.js"><link rel="prefetch" href="/assets/js/96.f12c7c46.js"><link rel="prefetch" href="/assets/js/97.83aad559.js"><link rel="prefetch" href="/assets/js/98.3e876f13.js"><link rel="prefetch" href="/assets/js/99.711d526d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a748b10c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/icon.png" alt="" class="logo"> <!----></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分享" class="dropdown-title"><span class="title">技术分享</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术分享" class="mobile-dropdown-title"><span class="title">技术分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javascript/javascript-learning-and-summary/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/html/html-learning-and-summary/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/css/css-learning-and-summary/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/webpack/webpack-learning-and-summary/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/ts/ts-learning-and-summary/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/nodejs/nodejs-learning-and-summary/" class="nav-link router-link-active">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/weex/weex-learning-and-summary/" class="nav-link">
  Weex
</a></li><li class="dropdown-item"><!----> <a href="/network/network-learning-and-summary/" class="nav-link">
  Network
</a></li><li class="dropdown-item"><!----> <a href="/datastructure/datastructure-learning-and-summary/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/mixin/mixin-learning-and-summary/" class="nav-link">
  日常杂记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Andraw-lin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术分享" class="dropdown-title"><span class="title">技术分享</span> <span class="arrow down"></span></button> <button type="button" aria-label="技术分享" class="mobile-dropdown-title"><span class="title">技术分享</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javascript/javascript-learning-and-summary/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/html/html-learning-and-summary/" class="nav-link">
  HTML
</a></li><li class="dropdown-item"><!----> <a href="/css/css-learning-and-summary/" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/react/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/webpack/webpack-learning-and-summary/" class="nav-link">
  Webpack
</a></li><li class="dropdown-item"><!----> <a href="/ts/ts-learning-and-summary/" class="nav-link">
  Typescript
</a></li><li class="dropdown-item"><!----> <a href="/nodejs/nodejs-learning-and-summary/" class="nav-link router-link-active">
  Nodejs
</a></li><li class="dropdown-item"><!----> <a href="/weex/weex-learning-and-summary/" class="nav-link">
  Weex
</a></li><li class="dropdown-item"><!----> <a href="/network/network-learning-and-summary/" class="nav-link">
  Network
</a></li><li class="dropdown-item"><!----> <a href="/datastructure/datastructure-learning-and-summary/" class="nav-link">
  数据结构
</a></li><li class="dropdown-item"><!----> <a href="/mixin/mixin-learning-and-summary/" class="nav-link">
  日常杂记
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/Andraw-lin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/nodejs/nodejs-learning-and-summary" class="sidebar-heading clickable router-link-active open"><span>Nodejs 学习和总结</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/nodejs/nodejs-learning-and-summary/Express-Build-Architecture-Based-On-Node-And-Mongodb.html" class="sidebar-link">基于nodejs+mongodb使用express搭建项目架构</a></li><li><a href="/nodejs/nodejs-learning-and-summary/Node-基础知识.html" class="sidebar-link">Nodejs 知识点总结</a></li><li><a href="/nodejs/nodejs-learning-and-summary/Koa-源码思考和学习.html" class="active sidebar-link">Koa 源码思考和学习</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/nodejs/nodejs-learning-and-summary/Koa-源码思考和学习.html#先从-new-koa-开始" class="sidebar-link">先从 new Koa() 开始</a></li><li class="sidebar-sub-header"><a href="/nodejs/nodejs-learning-and-summary/Koa-源码思考和学习.html#中间件处理函数的组合" class="sidebar-link">中间件处理函数的组合</a></li><li class="sidebar-sub-header"><a href="/nodejs/nodejs-learning-and-summary/Koa-源码思考和学习.html#上下文-context-的封装" class="sidebar-link">上下文 context 的封装</a></li><li class="sidebar-sub-header"><a href="/nodejs/nodejs-learning-and-summary/Koa-源码思考和学习.html#处理服务器所接收的请求" class="sidebar-link">处理服务器所接收的请求</a></li><li class="sidebar-sub-header"><a href="/nodejs/nodejs-learning-and-summary/Koa-源码思考和学习.html#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="koa-源码思考和学习"><a href="#koa-源码思考和学习" class="header-anchor">#</a> Koa 源码思考和学习</h1> <p>众所周知，Koa 和 Express 是 Nodejs 里常用到的两个 HTTP 库，并且它们两个是由同一个团队进行编写，其中 Express 沿用的是回调函数模式，Koa 则跟上 ECMAScript 发展，使用生成器来编写，到了 Koa 2.0 后则直接用上了 async/await，可以说 Koa 更加优于我们的编写。🤔</p> <p>最重要的一点，<strong>Koa 和 Express 都是以中间件作为核心</strong>，因此很多功能都是依赖社区实现和补充。Koa 内部实现很简单，主要包括了<strong>对 Context、Request 和 Response 的封装</strong>、<strong>中间件的组合</strong>两大块内容。</p> <p>接下来我们就来看看 Koa 2.0 源码实现。当然如果有兴趣的，可以直接去<a href="https://github.com/koajs/koa/blob/master/lib/application.js" target="_blank" rel="noopener noreferrer">Koa的github网址观看源码<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="先从-new-koa-开始"><a href="#先从-new-koa-开始" class="header-anchor">#</a> 先从 new Koa() 开始</h2> <p>如果你用过 Koa，肯定在编写入口文件时，必不可少的一句话就是<code>const app = new Koa()</code>，其实就是创建一个 Koa 实例，那么问题来了，Koa 构造函数都有哪些内容，不妨先来看看。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// ...</span>
<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  options <span class="token operator">=</span> options <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>proxy <span class="token operator">=</span> options<span class="token punctuation">.</span>proxy <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 是否允许代理</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>subdomainOffset <span class="token operator">=</span> options<span class="token punctuation">.</span>subdomainOffset <span class="token operator">||</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 从hostname解析子域的偏移起点，比如地址tobi.ferrets.example.com，偏移量为2时则为tobi.ferrets</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>proxyIpHeader <span class="token operator">=</span> options<span class="token punctuation">.</span>proxyIpHeader <span class="token operator">||</span> <span class="token string">'X-Forwarded-For'</span><span class="token punctuation">;</span> <span class="token comment">// 代理头部字段</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>maxIpsCount <span class="token operator">=</span> options<span class="token punctuation">.</span>maxIpsCount <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>env <span class="token operator">=</span> options<span class="token punctuation">.</span>env <span class="token operator">||</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">||</span> <span class="token string">'development'</span><span class="token punctuation">;</span> <span class="token comment">// 当前运行环境</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>keys<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>keys <span class="token operator">=</span> options<span class="token punctuation">.</span>keys<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>middleware <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 重点！！！用于存储中间件的数组</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Koa封装好的上下文</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>request <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Koa封装好的Request对象</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>response <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Koa封装好的Response对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>util<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>custom<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">[</span>util<span class="token punctuation">.</span>inspect<span class="token punctuation">.</span>custom<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>inspect<span class="token punctuation">;</span> <span class="token comment">// 赋予Koa的白名单属性，即创建实例后可访问属性</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// ...</span>
</code></pre></div><p>咋一看，其实基本都是一些代理配置和当前运行环境设置，其中**<code>middleware</code>属性则是用于存储中间件处理函数的数组**，另外**<code>context</code>属性、<code>request</code>属性、<code>response</code>属性就是 Koa 单独封装好的三个属性**，更好滴用于交互和处理。</p> <p>紧接着，我们先看看下面这个简单🌰：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token string">'haha'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>那么<code>app.use</code>这个 API 主要是做些什么事情呢？不妨直接跟你说，就是将中间件函数推进内部的<code>middleware</code>数组中进行保存用的。先来看看源码的实现。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Use the given middleware `fn`.
 *
 * Old-style middleware will be converted.
 *
 * @param {Function} fn
 * @return {Application} self
 * @api public
 */</span>
<span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'middleware must be a function!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 判断传入的参数是否为函数，否则直接抛出异常</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isGeneratorFunction</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断传入的参数是否为生成器函数</span>
    <span class="token function">deprecate</span><span class="token punctuation">(</span><span class="token string">'Support for generators will be removed in v3. '</span> <span class="token operator">+</span>
              <span class="token string">'See the documentation for examples of how to convert old middleware '</span> <span class="token operator">+</span>
              <span class="token string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fn <span class="token operator">=</span> <span class="token function">convert</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用koa-convert直接包装生成器函数</span>
  <span class="token punctuation">}</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">'use %s'</span><span class="token punctuation">,</span> fn<span class="token punctuation">.</span>_name <span class="token operator">||</span> fn<span class="token punctuation">.</span>name <span class="token operator">||</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将中间件处理函数直接放到内部数组中进行保存</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 最终返回当前Koa实例</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先明确一点的是，<code>app.use</code>该 API 中传入的参数必须是函数，除此之外，<strong>当传入的参数是生成器函数，那么就是需要使用<code>koa-convert</code>包装一层变成 Promise 中间件</strong>，具体可看看其<a href="https://github.com/koajs/convert" target="_blank" rel="noopener noreferrer">github地址<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，其实也是为了能够使 Koa 2.0 能够向前兼容，由于 Koa 1.x 用的就是生成器函数处理中间件。</p> <p>到了最后，就是直接将中间件处理函数一一存储到 Koa 实例的内部 middleware 属性中，便于后面使用。</p> <p>##app.listen() 后面究竟发生了什么</p> <p>如果你编写过原生 Node，估计对下方这坨代码并不陌生。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> host <span class="token operator">=</span> <span class="token string">'localhost'</span>
<span class="token keyword">const</span> port <span class="token operator">=</span> <span class="token number">3000</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">200</span>
  res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'haha...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> host<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The server is started...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上述就是直接创建一个 http 服务器，接着设置相应的返回状态以及内容。</p> <p>但是，从 Koa 本身的构造器中可以看到，它并没有设置任何的服务器相关内容，那么会在哪里？其实 Koa 都是自己封装到一个<code>listen</code>方法中，我们就来看看。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Shorthand for:
 *
 *    http.createServer(app.callback()).listen(...)
 *
 * @param {Mixed} ...
 * @return {Server}
 * @api public
 */</span>
<span class="token function">listen</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">'listen'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接通过http.createServer创建一个服务器</span>
  <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据传入的参数初始化http服务器</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到的是，Koa 已经为每一个实例都带了一个<code>listen</code>方法来创建一个相应的 http 服务器。那么重点来了，可以看到如果<strong>使用<code>app.listen</code>创建一个服务器时，都会调用 Koa 当前实例的<code>this.callback</code>方法，好明显，该方法执行完后肯定返回一个回调，就是用于处理请求的</strong>。那么我们就来看看该方法是做些什么事情的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Return a request handler callback
 * for node's native http server.
 *
 * @return {Function}
 * @api public
 */</span>
<span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重点！！！通过koa-compose组合所有中间件函数</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">listenerCount</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 全局监听错误事件</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleRequest</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 封装好的处理请求的函数</span>
    <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> handleRequest<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>看到这里，也许你会看的有点模糊，compose 是啥？this.createContext 和 this.handleRequest 这两个方法又是干嘛的？先不要急，目前我们就可以知道的就是，<strong>最终放进<code>http.createServer</code>中的回调函数就是下面这个：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 封装好的处理请求的函数</span>
  <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，接下来就到我们的重头戏啦。先介绍一下 compose 这个方法，究竟何方神圣！😄</p> <h2 id="中间件处理函数的组合"><a href="#中间件处理函数的组合" class="header-anchor">#</a> 中间件处理函数的组合</h2> <p>在开始之前，我先简单介绍一下著名的 Koa 中间件的洋葱模型图（来自网图，如侵权可删除）。
<img src="https://user-images.githubusercontent.com/15081323/78218999-4e6e1900-74f1-11ea-923f-246457adf2d1.png" alt="Koa中间件的洋葱模型图"></p> <p><strong>类似于 JavaScript 的 DOM 事件流处理方式，先从外层走到最内层，接着再从内层走到外层</strong>。简单来说，就是按任务优先级来进行划分处理，先将任务优先级最高的进行处理，然后再处理任务优先级低。</p> <p>也许你会好奇是如何实现从外到内，然后又从内到外的，在 Koa 2.0 中这一切都是通过 <strong>async/await</strong> 实现的，我们先来看看下面简单的🌰：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Koa <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'koa'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>

<span class="token comment">// 输出结果为</span>
<span class="token comment">// 1</span>
<span class="token comment">// 2</span>
<span class="token comment">// 3</span>
<span class="token comment">// 33</span>
<span class="token comment">// 22</span>
<span class="token comment">// 11</span>
</code></pre></div><p>既然是使用 async/await 实现，那总得需要把他们这些中间件回调函数都整合起来吧？没错，这就得益于<code>koa-compose</code>的处理，其实<code>koa-compose</code>在源码上的实现很简单，就是一个<code>compose</code>方法，我们就来看看它是如何实现。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Compose `middleware` returning
 * a fully valid middleware comprised
 * of all those which are passed.
 *
 * @param {Array} middleware
 * @return {Function}
 * @api public
 */</span>

<span class="token keyword">function</span> <span class="token function">compose</span> <span class="token punctuation">(</span><span class="token parameter">middleware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>middleware<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Middleware stack must be an array!'</span><span class="token punctuation">)</span> <span class="token comment">// 判断传入的中间件是否为一个数组</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> fn <span class="token keyword">of</span> middleware<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 遍历数组，逐个元素判断是否为函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Middleware must be composed of functions!'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">/**
   * @param {Object} context
   * @return {Promise}
   * @api public
   */</span>

  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// last called middleware #</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 开始执行流程</span>
    <span class="token keyword">function</span> <span class="token function">dispatch</span> <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'next() called multiple times'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      index <span class="token operator">=</span> i
      <span class="token keyword">let</span> fn <span class="token operator">=</span> middleware<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// 每次执行都拿当前遍历到的中间件函数出来</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> middleware<span class="token punctuation">.</span>length<span class="token punctuation">)</span> fn <span class="token operator">=</span> next <span class="token comment">// 当遍历的位置是最后一个时，那么中间件函数就是为空</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 当中间件函数为空时，直接执行Promise.resolve方法</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token function">dispatch</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 每次遍历都会返回一个Promise，并且在返回之前会执行当前遍历到的中间件函数</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上述代码中，可以看到蕴含很多知识点在这里面。首先就是运用了闭包存储了当前遍历的位置 index，因此在调用<code>compose</code>方法时，实质返回的就是<code>Promise.resolve(fn(context, dispatch.bind(null, i + 1)))</code>，在返回的过程中也会立马执行了当前遍历到的中间件函数。</p> <p>在这里，也许你在看代码的时候会有疑惑，<strong>Promise.resolve 里面第二个参数是<code>dispatch.bind(null, i + 1)</code>，这明显只是返回了一个<code>this</code>指向<code>windows</code>的函数鸭，那什么时候开始执行？</strong></p> <p>这个问题当时我也是感到迷惑地方，后面再结合上面<code>async/await</code>代码一看，结果就很明显，答案就在<code>await next()</code>里面，其中<code>next</code>函数就是<code>dispatch.bind(null, i + 1)</code>，这样一来又会重复<code>dispatch</code>过程。</p> <p>总结一下，<strong><code>compose</code>函数执行的是一个<code>dispatch</code>过程，所谓<code>dispatch</code>过程，就是将当前的中间件函数执行，其中<code>context</code>上下文作为中间件函数的第一个参数，<code>dispatch.bind(null, i + 1)</code>返回的绑定函数作为第二个参数，当执行<code>await next()</code>时会重新执行<code>dispatch</code>过程（即递归过程），最终使用<code>Promise.resolve</code>包转好返回</strong>。</p> <h2 id="上下文-context-的封装"><a href="#上下文-context-的封装" class="header-anchor">#</a> 上下文 context 的封装</h2> <p>我们接着回到上述这段 callback 的代码。如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Return a request handler callback
 * for node's native http server.
 *
 * @return {Function}
 * @api public
 */</span>
<span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重点！！！通过koa-compose组合所有中间件函数</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">listenerCount</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 全局监听错误事件</span>

  <span class="token keyword">const</span> <span class="token function-variable function">handleRequest</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 封装好的处理请求的函数</span>
    <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> handleRequest<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面我已经讲了 compose 的源码实现，那么下面就要来到<code>handleReques</code>函数，该函数也是最终作为<code>http.createServer()</code>的回调函数。</p> <p>先来看下<code>createContext</code>函数，好明显，看字面意思的话，该函数就是创建一个上下文 context 的意思。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Initialize a new context.
 *
 * @api private
 */</span>

<span class="token function">createContext</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将封装好的context作为原型对象</span>
  <span class="token keyword">const</span> request <span class="token operator">=</span> context<span class="token punctuation">.</span>request <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将封装好的request对象作为context.request对象的原型对象</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> context<span class="token punctuation">.</span>response <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将封装好的response对象作为context.response对象的原型对象</span>
  context<span class="token punctuation">.</span>app <span class="token operator">=</span> request<span class="token punctuation">.</span>app <span class="token operator">=</span> response<span class="token punctuation">.</span>app <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 将当前koa实例保存到context.app中</span>
  context<span class="token punctuation">.</span>req <span class="token operator">=</span> request<span class="token punctuation">.</span>req <span class="token operator">=</span> response<span class="token punctuation">.</span>req <span class="token operator">=</span> req<span class="token punctuation">;</span> <span class="token comment">// 将Node原生的req对象保存到context.req中</span>
  context<span class="token punctuation">.</span>res <span class="token operator">=</span> request<span class="token punctuation">.</span>res <span class="token operator">=</span> response<span class="token punctuation">.</span>res <span class="token operator">=</span> res<span class="token punctuation">;</span> <span class="token comment">// 将Node原生的res对象保存到context.res中</span>
  request<span class="token punctuation">.</span>ctx <span class="token operator">=</span> response<span class="token punctuation">.</span>ctx <span class="token operator">=</span> context<span class="token punctuation">;</span> <span class="token comment">// 将当前封装好的context对象保存到request.ctx和response.ctx上</span>
  request<span class="token punctuation">.</span>response <span class="token operator">=</span> response<span class="token punctuation">;</span> <span class="token comment">// 将封装好的response保存到request.response中</span>
  response<span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span> <span class="token comment">// 将封装好的request保存到response.request中</span>
  context<span class="token punctuation">.</span>originalUrl <span class="token operator">=</span> request<span class="token punctuation">.</span>originalUrl <span class="token operator">=</span> req<span class="token punctuation">.</span>url<span class="token punctuation">;</span> <span class="token comment">// 将当前请求的url保存到reqeust.originalUrl和context.originalUrl中</span>
  context<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> context<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，在原有封装好的<code>context</code>情况下，将 Koa 封装好的<code>this.request</code>和<code>this.response</code>对象保存一份到<code>context</code>上下文下。</p> <p>当然需要额外注意的是，<strong><code>this.request</code>和<code>this.response</code>都是 Koa 对请求和响应的封装，而<code>req</code>和<code>res</code>则是 Node 原生的 request 对象和 response 对象</strong>。</p> <p>总结一下，<strong>每当请求进入 HTTP 服务器时，都会在原封装好的<code>context</code>对象下添加<code>reuquest</code>和<code>response</code>，然后返回一个<code>context</code>对象（即没接受一个请求时，都会新创建一个<code>context</code>对象）</strong>。</p> <h2 id="处理服务器所接收的请求"><a href="#处理服务器所接收的请求" class="header-anchor">#</a> 处理服务器所接收的请求</h2> <p>到了这里，相信你应该知道要讲的就是<code>handleRequest</code>方法，该方法就是最终处理请求和响应的。先来看源码吧。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Handle request in callback.
 *
 * @api private
 */</span>

<span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token parameter">ctx<span class="token punctuation">,</span> fnMiddleware</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> ctx<span class="token punctuation">.</span>res<span class="token punctuation">;</span> <span class="token comment">// 先缓存Node上原生的response对象</span>
  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span> <span class="token comment">// 默认状态为404</span>
  <span class="token keyword">const</span> <span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> ctx<span class="token punctuation">.</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定义错误处理</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handleResponse</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">respond</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 定义最终返回给客户端的内容处理</span>
  <span class="token function">onFinished</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> onerror<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// HTTP 请求关闭、完成或错误时执行相应回调</span>
  <span class="token keyword">return</span> <span class="token function">fnMiddleware</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 按需执行相应的中间件函数，并在最后处理好返回给客户端</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，源码很简单，对于返回给客户端的内容处理都封装在<code>response</code>方法里面（这里暂不讨论，其实实现就是根据情况在res.end方法中返回）。</p> <p>然而，你会发现有一个方法<code>onFinished</code>很奇怪，它究竟是干嘛的？</p> <p>其实它就是<strong>当 HTTP 在请求关闭、完成或错误的过程中，发现存在监听到的事件发生时，就会立马执行，这样一来就不需要在每一个过程中都编写一遍</strong>。好比如上述的，使用 onerror 事件作为处理回调，明显的，当在请求关闭、完成或错误的过程中发现有错误发生时，便会调用一次 onerror 事件。</p> <p>到了最后，按序执行相应的中间件函数，并处理好的结果作为<code>respond</code>方法的参数，当然最后也是会将处理好的结果返回到客户端中。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p><strong>Koa 源码的核心在于中间件的处理，即洋葱模型。通过执行<code>compose</code>方法来递归执行<code>dispatch</code>方法，每递归一次就执行一次当前的中间件处理，执行完后，使用<code>Promise.resolve</code>包装一层并将结果返回</strong>。</p> <p>另外的话，也少不了对<code>context</code>对象、<code>request</code>对象、<code>response</code>对象的封装。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/nodejs/nodejs-learning-and-summary/Node-基础知识.html" class="prev">
        Nodejs 知识点总结
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.62b9dc26.js" defer></script><script src="/assets/js/2.1177bb59.js" defer></script><script src="/assets/js/80.dcf79b90.js" defer></script>
  </body>
</html>
